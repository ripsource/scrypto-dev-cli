"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.s = void 0;
const array_1 = require("./schemas/array");
const bool_1 = require("./schemas/bool");
const decimal_1 = require("./schemas/decimal");
const number_1 = require("./schemas/number");
const orderedTuple_1 = require("./schemas/orderedTuple");
const address_1 = require("./schemas/address");
const string_1 = require("./schemas/string");
const struct_1 = require("./schemas/struct");
const value_1 = require("./schemas/value");
const enum_1 = require("./schemas/enum"); // Add this import
const nonfungiblelocalid_1 = require("./schemas/nonfungiblelocalid");
const map_1 = require("./schemas/map");
const internalAddress_1 = require("./schemas/internalAddress");
const instant_1 = require("./schemas/instant");
const option_1 = require("./schemas/option");
/**
 * The main object through which to build schemas for parsing SBOR values.
 * This object contains methods for creating schemas for all the different types of values that can be parsed.
 * @example
 * ```ts
 * import { s } from '@calamari-radix/gateway-ez-mode';
 * const myStructSchema = s.struct({
 *   bing: s.string(),
 *   bong: s.number(),
 *   foo: s.struct({ bar: s.string() }),
 * });
 * ```
 *
 * Parsing can be done using the returned schema:
 * ```ts
 * const parsed = myStructSchema.safeParse(myProgrammaticScryptoSborValue);
 * ```
 */
exports.s = {
    /**
     * Essentially a no-op, this schema will return the raw ProgrammaticScryptoSborValue
     * Handy as fallback in case you can't parse your value for some reason.
     * @returns ValueSchema
     */
    value: () => new value_1.ValueSchema(),
    /**
     * A shema for any decimal, such as Decimal or PreciseDecimal
     * @returns DecimalSchema
     */
    decimal: () => new decimal_1.DecimalSchema(),
    /**
     * A schema for a String
     * @returns StringSchema
     */
    string: () => new string_1.StringSchema(),
    /**
     * A schema for a Bool
     * @returns BoolSchema
     */
    bool: () => new bool_1.BoolSchema(),
    /**
     * A schema for a NonFungibleLocalId
     * @returns NonFungibleLocalIdSchema
     */
    nonFungibleLocalId: () => new nonfungiblelocalid_1.NonFungibleLocalIdSchema(),
    /**
     * A schema for a Number
     * @returns NumberSchema
     */
    number: () => new number_1.NumberSchema(),
    /**
     * A schema for an Instant. This will parse the instant directly into a Date object
     * @returns InstantSchema
     */
    instant: () => new instant_1.InstantSchema(),
    /**
     * A schema for a Referenced Address, such as a global account, component, or resource address
     * @returns AddressSchema
     */
    address: () => new address_1.AddressSchema(),
    /**
     * A schema for an Internal (owned) Address, such as a Vault or KeyValueStore
     * @returns InternalAddressSchema
     */
    internalAddress: () => new internalAddress_1.InternalAddressSchema(),
    /**
     * A schema for a Struct
     * @param definition The struct definition, which is an object of schemas that describes the fields of the struct
     * @returns StructSchema
     * @example
     * ```ts
     * const myStructSchema = s.struct({
     *    bing: s.string(),
     *    bong: s.number(),
     *    foo: s.struct({ bar: s.string() }),
     * });
     * ```
     */
    struct: (definition) => new struct_1.StructSchema(definition, false),
    /**
     * A schema for a struct, where missing fields are allowed and parsed as `null`.
     * This is useful for when you don't know exactly what fields will be present in the struct.
     * @param definition The struct definition, which is an object of schemas that describes the fields of the struct
     * @returns StructSchema
     *
     * @example
     * ```ts
     * const myStructSchema = s.structNullable({
     *   bing: s.string(),
     *   bong: s.number(),
     *   foo: s.number(),
     * });
     * ```
     * Parsing a struct that doesn't have 'foo' will give back:
     * ```json
     * {
     *  bing: "hello",
     *  bong: 123,
     *  foo: null
     * }
     * ```
     */
    structNullable: (definition) => new struct_1.StructSchema(definition, true),
    // structNullable: <T extends StructDefinition>(definition: T) =>
    //     new StructSchema(definition, true),
    /**
     * A schema for an Ordered Tuple. The SBOR kind of "Tuple" is shared between Rust structs and tupled, so
     * we explicitly call this an OrderedTuple to avoid confusion.
     * @param schemas An array of schemas that describe the fields of the tuple
     * @returns OrderedTupleSchema
     * @example
     * ```ts
     * const myTupleSchema = s.orderedTuple([s.string(), s.number()]);
     * const myNestedTupleSchema = s.orderedTuple([s.string(), s.orderedTuple([s.number(), s.string()])]);
     * const structInTupleSchema = s.orderedTuple([s.struct({ foo: s.string() }), s.number()]);
     * ```
     */
    tuple: (schemas) => new orderedTuple_1.OrderedTupleSchema(schemas),
    /**
     * A schema for an Array
     * @param schema The schema that describes the elements of the array
     * @returns ArraySchema
     * @example
     * ```ts
     * const myArraySchema = s.array(s.string());
     * const myNestedArraySchema = s.array(s.array(s.number()));
     * ```
     */
    array: (schema) => new array_1.ArraySchema(schema),
    /**
     * A schema for an Enum
     * @param variants An array of variant definitions, which are objects with a string variant name and a schema.
     * The schema passed as "value" must be either a StructSchema or an OrderedTupleSchema. This has to do with
     * the fact that Rust represents enum values either with struct syntax or tuple syntax.
     * @returns EnumSchema
     * @example
     * ```ts
     * const myEnumSchema = s.enum([
     *     {
     *         variant: 'NonFungible',
     *         schema: s.struct({
     *             ids: s.array(s.nonFungibleLocalId()),
     *             resource_address: s.address(),
     *         }),
     *     },
     *     { variant: 'Fungible', schema: s.tuple([s.decimal()]) },
     * ]);
     * ```
     * Parsing a NonFungible will give back:
     * ```json
     * {
     *   variant: 'NonFungible',
     *   value: {
     *     ids: ["#1#", "#2#"],
     *     resource_address: "resource_rdx...."
     *   }
     * }
     * ```
     * Parsing a Fungible will give back:
     * ```json
     * {
     *   variant: 'Fungible',
     *   value: ["12345"]
     * }
     */
    enum: (variants) => new enum_1.EnumSchema(variants),
    /**
     * A utility schema for the Option enum in Rust. This is a common pattern in Rust to represent
     * nullable values. The Option schema takes a single schema as an argument, which describes the
     * type of the value inside the Option.
     * @param schema The schema that describes the type of the value inside the Option
     * @returns OptionSchema
     */
    option: (schema) => new option_1.OptionSchema(schema),
    /**
     * A schema for a Map
     * @param definition A definition that describes the type of the values in the map
     * @returns MapSchema
     * @example
     * ```ts
     * const myMapSchema = s.map({ key: s.string(), value: s.number() });
     * ```
     * Parsing a map will give back an Map object with the keys and values parsed according to the schema.
     */
    map: (definition) => new map_1.MapSchema(definition),
};
