"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstantSchema = void 0;
const sborSchema_1 = require("../sborSchema");
// Add this new class alongside your existing schemas
class InstantSchema extends sborSchema_1.SborSchema {
    constructor() {
        super(['I64']);
    }
    validate(value, path) {
        if (!this.kinds.includes(value.kind)) {
            throw new sborSchema_1.SborError(`Invalid number kind. Expected an I64`, path);
        }
        // help typescript to know that value is a number
        const number = value;
        // Validate that the value is a string representation of a number
        if (typeof number.value !== 'string') {
            throw new sborSchema_1.SborError('Number value must be a string', path);
        }
        // Parse the string to verify it's a valid number
        const numStr = number.value;
        const num = BigInt(numStr); // Use BigInt to handle large numbers
        // For unsigned integers, ensure the number is non-negative
        if (value.kind.startsWith('U') && num < 0) {
            throw new sborSchema_1.SborError('Unsigned integer cannot be negative', path);
        }
        // Check range constraints based on the kind
        const range = { min: -9223372036854775808n, max: 9223372036854775807n };
        if (num < range.min || num > range.max) {
            throw new sborSchema_1.SborError(`Number out of range for ${value.kind}. Must be between ${range.min} and ${range.max}`, path);
        }
        return true;
    }
    parse(value, path) {
        this.validate(value, path);
        const number = value;
        // number represents a unix timestamp in seconds
        const date = new Date(Number(number.value) * 1000);
        return date;
    }
}
exports.InstantSchema = InstantSchema;
