"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructSchema = void 0;
const sborSchema_1 = require("../sborSchema");
class StructSchema extends sborSchema_1.SborSchema {
    definition;
    allowMissing;
    /**
     * @param definition The struct definition.
     * @param allowMissing If true, missing fields are allowed and parsed as `null`;
     *                     if false, missing fields will be a parsing error.
     */
    constructor(definition, allowMissing) {
        super(['Tuple']);
        this.definition = definition;
        this.allowMissing = allowMissing;
    }
    validate(value, path) {
        if (!value ||
            typeof value !== 'object' ||
            !('kind' in value) ||
            value.kind !== 'Tuple') {
            throw new sborSchema_1.SborError('Invalid tuple structure', path);
        }
        const tupleValue = value;
        const fields = tupleValue.fields;
        const definedFields = Object.keys(this.definition);
        // If missing fields are not allowed, check for their existence.
        if (!this.allowMissing) {
            const fieldNames = fields.map((f) => f.field_name).filter(Boolean);
            const missingFields = definedFields.filter((name) => !fieldNames.includes(name));
            if (missingFields.length > 0) {
                throw new sborSchema_1.SborError(`Missing required fields: ${missingFields.join(', ')}`, path);
            }
        }
        // Validate each field if present.
        definedFields.forEach((name) => {
            const field = fields.find((f) => f.field_name === name);
            if (!field) {
                if (!this.allowMissing) {
                    throw new sborSchema_1.SborError(`Missing field: ${name}`, [
                        ...path,
                        name,
                    ]);
                }
                // If allowMissing is true, skip further validation.
                return;
            }
            const schema = this.definition[name];
            if (!schema.kinds.includes(field.kind)) {
                throw new sborSchema_1.SborError(`Expected kind ${schema.kinds} for field ${name}, got ${field.kind}`, [...path, name]);
            }
            schema.validate(field, [...path, name]);
        });
        return true;
    }
    parse(value, path) {
        this.validate(value, path);
        const tupleValue = value;
        const fields = tupleValue.fields;
        const result = {};
        Object.entries(this.definition).forEach(([name, schema]) => {
            const field = fields.find((f) => f.field_name === name);
            if (field) {
                result[name] = schema.parse(field, [
                    ...path,
                    name,
                ]);
            }
            else {
                // Only assign null if allowMissing is true.
                result[name] = null;
            }
        });
        return result;
    }
}
exports.StructSchema = StructSchema;
