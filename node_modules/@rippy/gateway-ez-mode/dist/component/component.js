"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchComponentInformation = fetchComponentInformation;
const metadata_1 = require("../data_extractors/metadata");
const nftData_1 = require("../data_extractors/nftData");
const error_1 = require("../error");
/**
 * Fetch component information from the gateway.
 * @throws {GatewayError} If an error occurs while fetching the information from the gateway API.
 * @throws {IncorrectAddressType} If the resource returned by the gateway call is not actually a component.
 * @throws {MissingFieldError} If no details are returned for a component
 */
async function fetchComponentInformation(gateway, componentAddresses) {
    let tokenInfoItems;
    try {
        tokenInfoItems =
            await gateway.state.getEntityDetailsVaultAggregated(componentAddresses);
    }
    catch (error) {
        throw new error_1.GatewayError(error);
    }
    return tokenInfoItems.flatMap((item) => {
        const metadataExtractor = new metadata_1.MetadataExtractor(item.metadata);
        const { name, description, tags } = metadataExtractor.getMetadataValuesBatch({
            name: 'String',
            description: 'String',
            tags: 'StringArray',
        });
        if (!item.details) {
            throw new error_1.MissingFieldError();
        }
        if (item.details.type !== 'Component') {
            throw new error_1.IncorrectAddressType();
        }
        const metadata = {
            name,
            description,
            tags,
            metadataExtractor,
        };
        const componentInfo = {
            componentAddress: item.address,
            metadata,
            blueprintVersion: item.details.blueprint_version || null,
            packageAddress: item.details.package_address || null,
            state: new nftData_1.SborDataExtractor(item.details.state ||
                undefined),
        };
        return componentInfo;
    });
}
