import { EntityMetadataCollection, MetadataTypedValue } from '@radixdlt/babylon-gateway-api-sdk';
type GetMetadataValueWithType<T extends MetadataTypedValue['type']> = Extract<MetadataTypedValue, {
    type: T;
}>;
export type OutputTypeForType<T extends MetadataTypedValue['type']> = GetMetadataValueWithType<T> extends {
    values: infer U;
} ? U : GetMetadataValueWithType<T> extends {
    value: infer U;
} ? U : never;
export type MetadataValueDescription = {
    [field_name: string]: MetadataTypedValue['type'];
};
export declare class MetadataExtractor {
    private metadataItems;
    constructor(metadataItems: EntityMetadataCollection);
    /**
     * Get the raw metadata items of the resource
     * @returns
     */
    getMetadataItemsRaw(): EntityMetadataCollection;
    /**
     * Get a single metadata value by field name
     * @param field_name The field name of the metadata value
     * @param type The type of the metadata value
     * @returns The metadata value or null if not found / type mismatch
     */
    getMetadataValue<T extends MetadataTypedValue['type']>(field_name: string, type: T): OutputTypeForType<T> | null;
    /**
     * Get multiple metadata values by field name
     * @param descriptions An object where the keys are field names and the values are the types of the metadata values
     * @returns An object where the keys are field names and the values are the metadata values or null if not found / type mismatch
     * @example
     * ```ts
     * const { symbol, name, tags } = resource.getMetadataValues({
     *    symbol: 'String',
     *    name: 'String',
     *    tags: 'StringArray',
     * })
     * symbol // string | null
     * name // string | null
     * tagas // string[] | null
     * ```
     */
    getMetadataValuesBatch<T extends MetadataValueDescription>(descriptions: T): {
        [K in keyof T]: OutputTypeForType<T[K]> | null;
    };
}
export {};
