"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pollTransactionStatus = exports.TransactionPollingTimeoutError = exports.TransactionPollingAbortedError = exports.TransactionPollingError = void 0;
const gatewayClient_1 = require("../gatewayClient");
class TransactionPollingError extends Error {
    constructor(message) {
        super(message);
        this.name = 'TransactionPollingError';
    }
}
exports.TransactionPollingError = TransactionPollingError;
class TransactionPollingAbortedError extends TransactionPollingError {
    constructor() {
        super('Transaction polling was aborted');
        this.name = 'TransactionPollingAbortedError';
    }
}
exports.TransactionPollingAbortedError = TransactionPollingAbortedError;
class TransactionPollingTimeoutError extends TransactionPollingError {
    constructor() {
        super('Transaction polling timed out');
        this.name = 'TransactionPollingTimeoutError';
    }
}
exports.TransactionPollingTimeoutError = TransactionPollingTimeoutError;
/**
 * Poll the status of a transaction until it is not pending.
 * @param transactionId - The ID of the transaction to poll.
 * @param options - Options for the polling.
 * @returns A promise that resolves to the transaction status.
 * @throws {TransactionPollingAbortedError} If the polling is aborted.
 * @throws {TransactionPollingTimeoutError} If the polling times out.
 */
const pollTransactionStatus = (transactionId, options) => {
    const { abortSignal, baseDelay = 1000, maxRetries = 10, maxDelay = 10000, delayFn = (retry) => Math.min(baseDelay * Math.pow(2, retry), maxDelay), gatewayApiClient = (0, gatewayClient_1.defaultGatewayClient)(), } = options || {};
    return (async () => {
        let response;
        let retry = 0;
        if (abortSignal?.aborted) {
            throw new TransactionPollingAbortedError();
        }
        abortSignal?.addEventListener('abort', () => {
            throw new TransactionPollingAbortedError();
        }, { once: true });
        while (!response && retry < maxRetries) {
            const result = await gatewayApiClient.transaction.getStatus(transactionId);
            if (result.intent_status !== 'Pending' &&
                result.intent_status !== 'LikelyButNotCertainRejection' &&
                result.intent_status !== 'Unknown') {
                response = result;
                break;
            }
            const delay = delayFn(retry);
            retry = retry + 1;
            await new Promise((resolve) => setTimeout(resolve, delay));
        }
        if (!response) {
            throw new TransactionPollingTimeoutError();
        }
        return response;
    })();
};
exports.pollTransactionStatus = pollTransactionStatus;
