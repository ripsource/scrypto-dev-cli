"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionStream = void 0;
const stateVersionManager_1 = require("./stateVersionManager");
const gatewayClient_1 = require("../gatewayClient");
const error_1 = require("../error");
/**
 * A stream of transactions from the Radix network. Allows you to
 * eaily fetch transactions in chronological order as they are
 * committed to the ledger.
 */
class TransactionStream {
    gateway;
    startStateVersion;
    batchSize;
    affected_entities;
    opt_ins;
    stateVersionManager;
    constructor({ gateway, startStateVersion, batchSize, opt_ins, affected_entities, stateVersionManager, }) {
        this.gateway = gateway;
        this.startStateVersion = startStateVersion;
        this.batchSize = batchSize;
        this.opt_ins = opt_ins;
        this.affected_entities = affected_entities;
        this.stateVersionManager = stateVersionManager;
    }
    /**
     * Create a new TransactionStream instance.
     *
     * @throws {GatewayError} If an error occurs while fetching data from the Radix Gateway API
     */
    static async create(input) {
        if (input.batchSize && input.batchSize > 100) {
            console.warn('Please note that the public Radix Gateway API has a limit of 100 transactions per page');
        }
        const gateway = input.gateway || (0, gatewayClient_1.defaultGatewayClient)();
        const stateVersionManager = new stateVersionManager_1.StateVersionManager({
            gatewayApi: gateway,
            startStateVersion: input.startStateVersion,
        });
        let stateVersion;
        try {
            stateVersion = await stateVersionManager.getStateVersion();
        }
        catch (error) {
            if (error instanceof error_1.GatewayError) {
                throw error;
            }
            else {
                throw new error_1.GatewayError(error);
            }
        }
        return new TransactionStream({
            gateway,
            startStateVersion: input.startStateVersion || stateVersion,
            batchSize: input.batchSize || 100,
            opt_ins: input.opt_ins,
            affected_entities: input.affected_entities,
            stateVersionManager,
        });
    }
    /**
     * Get the last seen state version. This is the state version of the last
     * transaction that was fetched from the stream.
     * @returns The last seen state version.
     * @throws {GatewayError} If an error occurs while fetching data from the Radix Gateway API
     */
    async lastSeenStateVersion() {
        return this.stateVersionManager.getStateVersion();
    }
    /**
     * Fetch the next batch of transactions from the stream.
     * @returns A promise that resolves with the next batch of transactions
     * from the stream. Once the stream is caught up with ledger, it may return an empty array
     * @throws {GatewayError} If an error occurs while fetching data from the Radix Gateway API
     */
    async next() {
        let stateVersion;
        try {
            stateVersion = await this.stateVersionManager.getStateVersion();
        }
        catch (error) {
            if (error instanceof error_1.GatewayError) {
                throw error;
            }
            else {
                throw new error_1.GatewayError(error);
            }
        }
        let transactions;
        try {
            transactions =
                await this.gateway.stream.innerClient.streamTransactions({
                    streamTransactionsRequest: {
                        from_ledger_state: {
                            state_version: stateVersion,
                        },
                        affected_global_entities_filter: this.affected_entities,
                        order: 'Asc',
                        kind_filter: 'User',
                        opt_ins: this.opt_ins || {
                            detailed_events: false,
                            manifest_instructions: false,
                            affected_global_entities: false,
                            balance_changes: false,
                        },
                        limit_per_page: this.batchSize,
                        transaction_status_filter: 'Success',
                    },
                });
        }
        catch (error) {
            throw new error_1.GatewayError(error);
        }
        this.stateVersionManager.setStateVersion(transactions.items.at(-1)?.state_version || stateVersion);
        return {
            transactions: transactions.items.filter((item) => item.state_version > stateVersion),
            lastSeenStateVersion: stateVersion,
        };
    }
}
exports.TransactionStream = TransactionStream;
