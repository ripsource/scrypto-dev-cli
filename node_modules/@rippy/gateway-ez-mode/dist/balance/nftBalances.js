"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNonFungibleBalancesForComponent = getNonFungibleBalancesForComponent;
const babylon_gateway_api_sdk_1 = require("@radixdlt/babylon-gateway-api-sdk");
const nftData_1 = require("../data_extractors/nftData");
const information_1 = require("../resource/information");
const sbor_ez_mode_1 = __importDefault(require("@calamari-radix/sbor-ez-mode"));
const error_1 = require("../error");
/**
 * Fetches non-fungible balances for a given address
 * @param gatewayApi The Radix Gateway API client
 * @param address The component address to fetch non-fungible balances for (which may be an account)
 * @returns A list of non-fungible balances
 *
 * @throws {GatewayError} If an error occurs while fetching data from the Radix Gateway API
 * @throws {IncorrectAddressType} If the address of the resource is not of the correct type
 */
async function getNonFungibleBalancesForComponent(gatewayApi, address) {
    // Define request for non-fungible resources
    const request = {
        address: address,
        aggregation_level: babylon_gateway_api_sdk_1.ResourceAggregationLevel.Vault,
        opt_ins: {
            non_fungible_include_nfids: true,
        },
    };
    // Fetch first page of non-fungible resources
    let nonFungibles;
    try {
        nonFungibles =
            await gatewayApi.state.innerClient.entityNonFungiblesPage({
                stateEntityNonFungiblesPageRequest: request,
            });
    }
    catch (error) {
        throw new error_1.GatewayError(error);
    }
    // Fetch additional pages if they exist
    let next_cursor_non_fungibles = nonFungibles.next_cursor;
    while (next_cursor_non_fungibles) {
        let nextBalances;
        try {
            nextBalances =
                await gatewayApi.state.innerClient.entityNonFungiblesPage({
                    stateEntityNonFungiblesPageRequest: {
                        ...request,
                        cursor: next_cursor_non_fungibles,
                        at_ledger_state: {
                            state_version: nonFungibles.ledger_state.state_version,
                        },
                    },
                });
        }
        catch (error) {
            throw new error_1.GatewayError(error);
        }
        next_cursor_non_fungibles = nextBalances.next_cursor;
        nonFungibles.items.push(...nextBalances.items);
    }
    // Get token addresses and fetch token details
    const tokenAddresses = nonFungibles.items.map((item) => item.resource_address);
    let tokenInfoItems;
    try {
        tokenInfoItems = await (0, information_1.fetchResourceInformation)(gatewayApi, tokenAddresses);
    }
    catch (error) {
        throw new error_1.GatewayError(error);
    }
    const nonFungibleResults = nonFungibles.items.map((item) => {
        // this should never happen because we are querying with AggregationLevel.Vault
        if (item.aggregation_level !== babylon_gateway_api_sdk_1.ResourceAggregationLevel.Vault) {
            throw new Error('Unexpected aggregation level');
        }
        const tokenInfoItem = tokenInfoItems.find((tokenInfo) => tokenInfo.resourceAddress == item.resource_address);
        // This should never happen because if we query for a resource address, we should get that resource back
        if (!tokenInfoItem) {
            throw new Error(`Token info not found for resource address ${item.resource_address}`);
        }
        if (tokenInfoItem.type !== 'NonFungible')
            throw new error_1.IncorrectAddressType();
        const nonFungibleIds = item.vaults.items.flatMap((item) => item.items || []);
        return (async () => {
            if (nonFungibleIds.length == 0) {
                return {
                    resourceInfo: tokenInfoItem,
                    nftBalance: [],
                };
            }
            let nftData;
            try {
                nftData = await gatewayApi.state.innerClient.nonFungibleData({
                    stateNonFungibleDataRequest: {
                        non_fungible_ids: item.vaults.items.flatMap((item) => item.items || []),
                        resource_address: item.resource_address,
                        at_ledger_state: {
                            state_version: nonFungibles.ledger_state.state_version,
                        },
                    },
                });
            }
            catch (error) {
                throw new error_1.GatewayError(error);
            }
            const parsed = nftData.non_fungible_ids.map((item) => {
                if (!item.data?.programmatic_json) {
                    return {
                        id: item.non_fungible_id,
                        keyImageUrl: null,
                        name: null,
                        description: null,
                        nftData: null,
                    };
                }
                const sborExtractor = new nftData_1.SborDataExtractor(item.data?.programmatic_json);
                const { key_image_url, name, description } = sborExtractor
                    .getWithSchema(sbor_ez_mode_1.default.structNullable({
                    key_image_url: sbor_ez_mode_1.default.string(),
                    name: sbor_ez_mode_1.default.string(),
                    description: sbor_ez_mode_1.default.string(),
                }))
                    .unwrapOr({
                    key_image_url: null,
                    name: null,
                    description: null,
                });
                return {
                    id: item.non_fungible_id,
                    keyImageUrl: key_image_url,
                    name: name,
                    description: description,
                    nftData: sborExtractor,
                };
            });
            return {
                resourceInfo: tokenInfoItem,
                nftBalance: parsed,
            };
        })();
    });
    return Promise.all(nonFungibleResults);
}
