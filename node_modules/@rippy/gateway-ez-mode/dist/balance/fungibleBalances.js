"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFungibleBalancesForComponent = getFungibleBalancesForComponent;
const babylon_gateway_api_sdk_1 = require("@radixdlt/babylon-gateway-api-sdk");
const information_1 = require("../resource/information");
const error_1 = require("../error");
/**
 * Get the fungible balances for a component.
 * @param gatewayApi The Radix Gateway API client
 * @param address The address of the component to fetch fungible balances for
 * @returns A list of fungible balances
 * @throws {GatewayError} If an error occurs while fetching data from the Radix Gateway API
 * @throws {IncorrectAddressType} If the address is not actually a component
 */
async function getFungibleBalancesForComponent(gatewayApi, address) {
    let balances;
    try {
        balances = await gatewayApi.state.innerClient.entityFungiblesPage({
            stateEntityFungiblesPageRequest: {
                address: address,
                aggregation_level: babylon_gateway_api_sdk_1.ResourceAggregationLevel.Global,
            },
        });
    }
    catch (error) {
        throw new error_1.GatewayError(error);
    }
    let next_cursor = balances.next_cursor;
    while (next_cursor) {
        let nextBalances;
        try {
            nextBalances =
                await gatewayApi.state.innerClient.entityFungiblesPage({
                    stateEntityFungiblesPageRequest: {
                        address: address,
                        aggregation_level: babylon_gateway_api_sdk_1.ResourceAggregationLevel.Global,
                        cursor: next_cursor,
                        at_ledger_state: {
                            state_version: balances.ledger_state.state_version,
                        },
                    },
                });
        }
        catch (error) {
            throw new error_1.GatewayError(error);
        }
        next_cursor = nextBalances.next_cursor;
        balances.items.push(...nextBalances.items);
    }
    const tokenAddresses = balances.items.map((item) => item.resource_address) || [];
    let tokenInfoItems;
    try {
        tokenInfoItems = await (0, information_1.fetchResourceInformation)(gatewayApi, tokenAddresses);
    }
    catch (error) {
        throw new error_1.GatewayError(error);
    }
    return balances.items.map((item) => {
        // This should never happen, because in our request we specify that we want global aggregation
        if (item.aggregation_level !== babylon_gateway_api_sdk_1.ResourceAggregationLevel.Global) {
            throw new Error('Unexpected aggregation level');
        }
        const tokenInfo = tokenInfoItems.find((tokenInfo) => tokenInfo.resourceAddress == item.resource_address);
        // This should never happen, because if we query for a resource address, we should get that resource back
        if (!tokenInfo) {
            throw new Error(`Token info not found for resource address ${item.resource_address}`);
        }
        if (tokenInfo.type !== 'Fungible')
            throw new error_1.IncorrectAddressType();
        return {
            resourceInfo: tokenInfo,
            balance: item.amount,
        };
    });
}
